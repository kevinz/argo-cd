<!-- TRANSLATED by md-translate -->
# 声明式设置

Argo CD 应用程序、项目和配置清单可使用 Kubernetes 清单声明式定义。 这些清单可被 `kubectl apply` 更新，而无需接触 `argocd` 命令行工具。

## 快速参考

所有资源，包括 `Application` 和 `AppProject` 规格，都必须安装在 Argo CD 名称空间（默认为 `argocd`）中。

#### 原子构型

| 样本文件 | 资源名称 | 种类 | 描述 | |-----------------------------------------------------------------------|------------------------------------------------------------------------------------|-----------|--------------------------------------------------------------------------------------||| [`argocd-cm.yaml`](argocd-cm-yaml.md) | argocd-cm | ConfigMap | 一般 Argo CD 配置 | | [`argocd-repositories.yaml`](argocd-repositories-yaml.md) | my-private-repo / istio-helm-repo / private-helm-repo / private-repo | secrets | 样本资源库连接详情

对于每种特定的 configmaps 和 Secret 资源，只有一个支持的资源名称（如上表所列）--如果需要合并，需要在创建之前进行。

警告 "关于 ConfigMap 资源的注意事项" 请务必使用标签 `app.kubernetes.io/part-of: argocd` 对 ConfigMap 资源进行引用，否则 Argo CD 将无法使用这些资源。

### 多个配置对象

| 样本文件 | 类型 | 说明 | ||------------------------------------------------------------------|-------------|--------------------------| | [`application.yaml`](../user-guide/application-specification.md) | 应用程序 | 示例应用程序规范 | | [`project.yaml`](./project-specification.md) | AppProject | 示例项目规范 | | - | 秘密 | 存储库凭据

对于 "应用程序 "和 "应用程序项目 "资源，资源名称等同于 Argo CD 中应用程序或项目的名称。 这也意味着应用程序和项目名称在给定的 Argo CD 安装中是唯一的，不能为两个不同的应用程序设置相同的应用程序名称。

## 应用

应用程序 CRD 是 Kubernetes 资源对象，代表环境中已部署的应用程序实例。 它由两个关键信息定义：

* 源 "指向 Git 中所需的状态（版本库、修订、路径、环境）
* 目标集群和名称空间的 `destination` 引用。集群可以被引用服务器或名称中的一个，但不能同时被引用（否则会出错）。在引擎盖下，如果缺少服务器，则会根据名称计算服务器，并用于任何操作。

最低应用规格如下

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: guestbook
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/argoproj/argocd-example-apps.git
    targetRevision: HEAD
    path: guestbook
  destination:
    server: https://kubernetes.default.svc
    namespace: guestbook
```

有关其他字段，请参阅 [application.yaml](application.yaml) 。 只要完成了 [Getting Started](../getting_started.md#1-install-argo-cd) 的第一步，就可以用 `kubectl apply -n argocd -f application.yaml` 来应用，Argo CD 就会开始部署留言簿应用程序。

注意 命名空间必须与 Argo CD 实例的命名空间相匹配，通常是 `argocd`。

注意 从 helm 资源库创建应用程序时，必须在 `spec.source` 中指定 `chart` 属性，而不是 `path` 属性。

```yaml
spec:
  source:
    repoURL: https://argoproj.github.io/argo-helm
    chart: argo
```

警告 如果没有 `resources-finalizer.argocd.argoproj.io` Finalizer，删除应用程序将不会删除其管理的资源。 要执行级联删除，必须添加 Finalizer。 请参阅 [应用程序删除](../user-guide/app_deletion.md#about-the-deletion-finalizer)。

```yaml
metadata:
  finalizers:
    - resources-finalizer.argocd.argoproj.io
```

### 应用程序中的应用程序

您可以创建一个应用程序来创建其他应用程序，而其他应用程序又可以创建其他应用程序。 这样，您就可以声明式地管理一组应用程序，这些应用程序可以协同部署和配置。

请参阅 [集群引导](cluster-bootstrapping.md)。

## 项目

AppProject CRD 是 Kubernetes 资源对象，代表应用程序的逻辑分组。 它由以下关键信息定义：

* `sourceRepos` 指向项目中的应用程序可从中提取配置清单的资源库。
* destinations`指向项目内应用程序可部署到的集群和 namespace。
* 角色 "实体列表，其中定义了它们对项目内资源的访问权限。

如果项目的 `destinations` 配置允许部署到安装 Argo CD 的命名空间，则该项目下的应用程序具有管理员级访问权限。应谨慎限制对管理员级项目的 [RBAC 访问权限](https://argo-cd.readthedocs.io/en/stable/operator-manual/rbac/)，并应限制只有管理员才能推送允许的 `sourceRepos` 访问权限。

规格示例如下

```yaml
apiVersion: argoproj.io/v1alpha1
kind: AppProject
metadata:
  name: my-project
  namespace: argocd
  # Finalizer that ensures that project is not deleted until it is not referenced by any application
  finalizers:
    - resources-finalizer.argocd.argoproj.io
spec:
  description: Example Project
  # Allow manifests to deploy from any Git repos
  sourceRepos:
  - '*'
  # Only permit applications to deploy to the guestbook namespace in the same cluster
  destinations:
  - namespace: guestbook
    server: https://kubernetes.default.svc
  # Deny all cluster-scoped resources from being created, except for Namespace
  clusterResourceWhitelist:
  - group: ''
    kind: Namespace
  # Allow all namespaced-scoped resources to be created, except for ResourceQuota, LimitRange, NetworkPolicy
  namespaceResourceBlacklist:
  - group: ''
    kind: ResourceQuota
  - group: ''
    kind: LimitRange
  - group: ''
    kind: NetworkPolicy
  # Deny all namespaced-scoped resources from being created, except for Deployment and StatefulSet
  namespaceResourceWhitelist:
  - group: 'apps'
    kind: Deployment
  - group: 'apps'
    kind: StatefulSet
  roles:
  # A role which provides read-only access to all applications in the project
  - name: read-only
    description: Read-only privileges to my-project
    policies:
    - p, proj:my-project:read-only, applications, get, my-project/*, allow
    groups:
    - my-oidc-group
  # A role which provides sync privileges to only the guestbook-dev application, e.g. to provide
  # sync privileges to a CI system
  - name: ci-role
    description: Sync privileges for guestbook-dev
    policies:
    - p, proj:my-project:ci-role, applications, sync, my-project/guestbook-dev, allow
    # NOTE: JWT tokens can only be generated by the API server and the token is not persisted
    # anywhere by Argo CD. It can be prematurely revoked by removing the entry from this list.
    jwtTokens:
    - iat: 1535390316
```

## 存储库

注意 有些 Git 主机（特别是 GitLab，也可能是内部 GitLab 实例）要求您在版本库 URL 中指定后缀`.git`，否则它们会发送 HTTP 301 重定向到后缀为`.git`的版本库 URL。 Argo CD 不会****这些重定向，所以您必须调整您的版本库 URL 后缀为`.git`。

版本库的详细信息存储在秘密中。 要配置一个版本库，需要创建一个包含版本库详细信息的秘密。可以考虑使用 [bitnami-labs/sealed-secrets](https://github.com/bitnami-labs/sealed-secrets) 将加密的秘密定义作为 Kubernetes 配置清单来存储。 每个版本库都必须有一个 `url` 字段，根据使用 HTTPS、SSH 还是 GitHub App 进行连接，还必须有 `username` 和 `password` （用于 HTTPS）、 `sshPrivateKey` （用于 SSH）或 `githubAppPrivateKey` （用于 GitHub App）。

!!警告 当使用 [bitnami-labs/sealed-secrets](https://github.com/bitnami-labs/sealed-secrets) 时，标签将被移除，必须按照这里的描述重新加入： https://github.com/bitnami-labs/sealed-secrets#sealedsecrets-as-templates-for-secrets

HTTPS 示例：

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: private-repo
  namespace: argocd
  labels:
    argocd.argoproj.io/secret-type: repository
stringData:
  type: git
  url: https://github.com/argoproj/private-repo
  password: my-password
  username: my-username
```

SSH 示例：

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: private-repo
  namespace: argocd
  labels:
    argocd.argoproj.io/secret-type: repository
stringData:
  type: git
  url: git@github.com:argoproj/my-private-repository.git
  sshPrivateKey: |
    -----BEGIN OPENSSH PRIVATE KEY-----
    ...
    -----END OPENSSH PRIVATE KEY-----
```

GitHub 应用程序示例：

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: github-repo
  namespace: argocd
  labels:
    argocd.argoproj.io/secret-type: repository
stringData:
  type: git
  url: https://github.com/argoproj/my-private-repository
  githubAppID: 1
  githubAppInstallationID: 2
  githubAppPrivateKey: |
    -----BEGIN OPENSSH PRIVATE KEY-----
    ...
    -----END OPENSSH PRIVATE KEY-----
---
apiVersion: v1
kind: Secret
metadata:
  name: github-enterprise-repo
  namespace: argocd
  labels:
    argocd.argoproj.io/secret-type: repository
stringData:
  type: git
  url: https://ghe.example.com/argoproj/my-private-repository
  githubAppID: 1
  githubAppInstallationID: 2
  githubAppEnterpriseBaseUrl: https://ghe.example.com/api/v3
  githubAppPrivateKey: |
    -----BEGIN OPENSSH PRIVATE KEY-----
    ...
    -----END OPENSSH PRIVATE KEY-----
```

谷歌云源存储库示例：

```yaml
kind: Secret
metadata:
  name: github-repo
  namespace: argocd
  labels:
    argocd.argoproj.io/secret-type: repository
stringData:
  type: git
  url: https://source.developers.google.com/p/my-google-project/r/my-repo
  gcpServiceAccountKey: |
    {
      "type": "service_account",
      "project_id": "my-google-project",
      "private_key_id": "REDACTED",
      "private_key": "-----BEGIN PRIVATE KEY-----\nREDACTED\n-----END PRIVATE KEY-----\n",
      "client_email": "argocd-service-account@my-google-project.iam.gserviceaccount.com",
      "client_id": "REDACTED",
      "auth_uri": "https://accounts.google.com/o/oauth2/auth",
      "token_uri": "https://oauth2.googleapis.com/token",
      "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
      "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/argocd-service-account%40my-google-project.iam.gserviceaccount.com"
    }
```

！！！提示 Kubernetes 文档中有[创建包含私钥的 secret 的说明](https://kubernetes.io/docs/concepts/configuration/secret/#use-case-pod-with-ssh-keys)。

### 存储库证书

如果想在多个资料库中使用相同的凭证，可以配置凭证模板。 凭证模板可以携带与资料库相同的凭证信息。

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: first-repo
  namespace: argocd
  labels:
    argocd.argoproj.io/secret-type: repository
stringData:
  type: git
  url: https://github.com/argoproj/private-repo
---
apiVersion: v1
kind: Secret
metadata:
  name: second-repo
  namespace: argocd
  labels:
    argocd.argoproj.io/secret-type: repository
stringData:
  type: git
  url: https://github.com/argoproj/other-private-repo
---
apiVersion: v1
kind: Secret
metadata:
  name: private-repo-creds
  namespace: argocd
  labels:
    argocd.argoproj.io/secret-type: repo-creds
stringData:
  type: git
  url: https://github.com/argoproj
  password: my-password
  username: my-username
```

在上例中，每个通过 HTTPS 访问的、URL 前缀为 `https://github.com/argoproj` 的版本库，都会使用存储在密钥 `username` 中的用户名和存储在密钥 `password` 中的密码 `private-repo-creds` 来连接 Git。

Argo CD 要被引用到任何给定存储库的凭证模板，必须满足以下条件：

* 必须完全未配置存储库，或者如果已配置，则必须不包含任何凭据信息（即不包含任何 `sshPrivateKey`、`username`、`password`）。
* 为凭证模板配置的 URL（如 `https://github.com/argoproj`）必须与版本库 URL（如 `https://github.com/argoproj/argocd-example-apps`）的前缀相匹配。

注意：凭证模板 URL 前缀的匹配是以_最佳匹配_的方式进行的，因此最长（最佳）的匹配将优先。 与 v1.4 之前的配置相比，定义的顺序并不重要。

以下密钥可用于引用证书秘密：

#### SSH 资源库

* sshPrivateKey "指用于访问存储库的 SSH 私钥

#### HTTPS 资源库

* 用户名 "和 "密码 "指访问存储库的用户名和/或密码
* tlsClientCertData "和 "tlsClientCertKey "指存储 TLS 客户证书（"tlsClientCertData"）和相应私钥 "tlsClientCertKey "的秘密，用于访问资源库。

#### GitHub 应用程序存储库

* githubAppPrivateKey "指用于访问版本库的 GitHub 应用程序私钥
* githubAppID "指你创建的应用程序的 GitHub 应用程序 ID。
* githubAppInstallationID "指你创建并安装的 GitHub 应用程序的安装 ID。
* githubAppEnterpriseBaseUrl "指 GitHub 企业版的基础 api URL（例如，"https://ghe.example.com/api/v3"）。
* tlsClientCertData "和 "tlsClientCertKey "指存储 TLS 客户端证书（"tlsClientCertData"）和相应私钥（"tlsClientCertKey"）的存储秘密，如果使用自定义证书，则用于访问 GitHub Enterprise。

### 使用自签名 TLS 证书（或由自定义 CA 签名）的存储库

你可以在名为 "argocd-tls-certs-cm "的 ConfigMap 对象中管理用于验证版本库服务器真实性的 TLS 证书。 数据部分应包含一个映射，以版本库服务器的主机名部分（而非完整的 URL）作为密钥，以 PEM 格式的证书作为数据。因此，如果你使用 URL `https://server.example.com/repos/my-repo` 连接到版本库，则应使用 `server.example.com` 作为密钥。证书数据应是服务器的证书（如果是自签证书）或用于签署服务器证书的 CA 的证书。 你可以为每个服务器配置多个证书，例如，如果你计划进行证书滚动。

如果没有为版本库服务器配置专用证书，系统默认的信任存储将被用于验证服务器的版本库。 对于大多数（如果不是全部）公共 Git 版本库服务（如 GitLab、GitHub 和 Bitbucket）以及大多数被引用知名 CA（包括 Let's Encrypt 证书）证书的私有托管网站来说，这已经足够了。

ConfigMap 对象示例：

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: argocd-tls-certs-cm
  namespace: argocd
  labels:
    app.kubernetes.io/name: argocd-cm
    app.kubernetes.io/part-of: argocd
data:
  server.example.com: |
    -----BEGIN CERTIFICATE-----
    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
    XWyb96wrUlv+E8I=
    -----END CERTIFICATE-----
```

注意 `argocd-tls-certs-cm` ConfigMap 将作为卷挂载到 `argocd-server` 和 `argocd-repo-server` 的 pod 中的挂载路径 `/app/config/tls`。 它将为挂载路径目录中的每个数据密钥创建文件，因此上面的示例将留下包含证书数据的文件 `/app/config/tls/server.example.com`。 ConfigMap 中的更改可能需要一段时间才能反映到你的 pod 中，这取决于你的 Kubernetes 配置。

### SSH 已知主机公钥

如果要将版本库配置为使用 SSH，Argo CD 将需要知道它们的 SSH 公钥。 为了让 Argo CD 通过 SSH 进行连接，每个版本库服务器的公钥必须预先在 Argo CD 中配置好（与 TLS 配置不同），否则与版本库的连接将失败。

可以在 `argocd-ssh-known-hosts-cm` ConfigMap 中管理 SSH 的已知主机数据。 该 ConfigMap 包含单个条目 `ssh_known_hosts`，其值为 SSH 服务器的公钥。 可以从任何现有的 `ssh_known_hosts` 文件或 `ssh-keyscan` 工具（OpenSSH 客户端包的一部分）的输出中填写该值。基本格式为 `<server_name> <keytype> <base64-encoded_key>`，每行一个条目。

下面是运行 `ssh-keyscan` 的示例：

```bash
$ for host in bitbucket.org github.com gitlab.com ssh.dev.azure.com vs-ssh.visualstudio.com ; do ssh-keyscan $host 2> /dev/null ; done
bitbucket.org ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDQeJzhupRu0u0cdegZIa8e86EG2qOCsIsD1Xw0xSeiPDlCr7kq97NLmMbpKTX6Esc30NuoqEEHCuc7yWtwp8dI76EEEB1VqY9QJq6vk+aySyboD5QF61I/1WeTwu+deCbgKMGbUijeXhtfbxSxm6JwGrXrhBdofTsbKRUsrN1WoNgUa8uqN1Vx6WAJw1JHPhglEGGHea6QICwJOAr/6mrui/oB7pkaWKHj3z7d1IC4KWLtY47elvjbaTlkN04Kc/5LFEirorGYVbt15kAUlqGM65pk6ZBxtaO3+30LVlORZkxOh+LKL/BvbZ/iRNhItLqNyieoQj/uh/7Iv4uyH/cV/0b4WDSd3DptigWq84lJubb9t/DnZlrJazxyDCulTmKdOR7vs9gMTo+uoIrPSb8ScTtvw65+odKAlBj59dhnVp9zd7QUojOpXlL62Aw56U4oO+FALuevvMjiWeavKhJqlR7i5n9srYcrNV7ttmDw7kf/97P5zauIhxcjX+xHv4M=
github.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOMqqnkVzrm0SdG6UOoqKLsabgH5C9okWi0dh2l9GKJl
github.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCj7ndNxQowgcQnjshcLrqPEiiphnt+VTTvDP6mHBL9j1aNUkY4Ue1gvwnGLVlOhGeYrnZaMgRK6+PKCUXaDbC7qtbW8gIkhL7aGCsOr/C56SJMy/BCZfxd1nWzAOxSDPgVsmerOBYfNqltV9/hWCqBywINIR+5dIg6JTJ72pcEpEjcYgXkE2YEFXV1JHnsKgbLWNlhScqb2UmyRkQyytRLtL+38TGxkxCflmO+5Z8CSSNY7GidjMIZ7Q4zMjA2n1nGrlTDkzwDCsw+wqFPGQA179cnfGWOWRVruj16z6XyvxvjJwbz0wQZ75XK5tKSb7FNyeIEs4TT4jk+S4dhPeAUC5y+bDYirYgM4GC7uEnztnZyaVWQ7B381AK4Qdrwt51ZqExKbQpTUNn+EjqoTwvqNj4kqx5QUCI0ThS/YkOxJCXmPUWZbhjpCg56i+2aB6CmK2JGhn57K5mj0MNdBXA4/WnwH6XoPWJzK5Nyu2zB3nAZp+S5hpQs+p1vN1/wsjk=
github.com ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBEmKSENjQEezOmxkZMy7opKgwFB9nkt5YRrYMjNuG5N87uRgg6CLrbo5wAdT/y6v0mKV0U2w0WZ2YB/++Tpockg=
gitlab.com ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBFSMqzJeV9rUzU4kWitGjeR4PWSa29SPqJ1fVkhtj3Hw9xjLVXVYrU9QlYWrOLXBpQ6KWjbjTDTdDkoohFzgbEY=
gitlab.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIAfuCHKVTjquxvt6CM6tdG4SLp1Btn/nOeHHE5UOzRdf
gitlab.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCsj2bNKTBSpIYDEGk9KxsGh3mySTRgMtXL583qmBpzeQ+jqCMRgBqB98u3z++J1sKlXHWfM9dyhSevkMwSbhoR8XIq/U0tCNyokEi/ueaBMCvbcTHhO7FcwzY92WK4Yt0aGROY5qX2UKSeOvuP4D6TPqKF1onrSzH9bx9XUf2lEdWT/ia1NEKjunUqu1xOB/StKDHMoX4/OKyIzuS0q/T1zOATthvasJFoPrAjkohTyaDUz2LN5JoH839hViyEG82yB+MjcFV5MU3N1l1QL3cVUCh93xSaua1N85qivl+siMkPGbO5xR/En4iEY6K2XPASUEMaieWVNTRCtJ4S8H+9
ssh.dev.azure.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC7Hr1oTWqNqOlzGJOfGJ4NakVyIzf1rXYd4d7wo6jBlkLvCA4odBlL0mDUyZ0/QUfTTqeu+tm22gOsv+VrVTMk6vwRU75gY/y9ut5Mb3bR5BV58dKXyq9A9UeB5Cakehn5Zgm6x1mKoVyf+FFn26iYqXJRgzIZZcZ5V6hrE0Qg39kZm4az48o0AUbf6Sp4SLdvnuMa2sVNwHBboS7EJkm57XQPVU3/QpyNLHbWDdzwtrlS+ez30S3AdYhLKEOxAG8weOnyrtLJAUen9mTkol8oII1edf7mWWbWVf0nBmly21+nZcmCTISQBtdcyPaEno7fFQMDD26/s0lfKob4Kw8H
vs-ssh.visualstudio.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC7Hr1oTWqNqOlzGJOfGJ4NakVyIzf1rXYd4d7wo6jBlkLvCA4odBlL0mDUyZ0/QUfTTqeu+tm22gOsv+VrVTMk6vwRU75gY/y9ut5Mb3bR5BV58dKXyq9A9UeB5Cakehn5Zgm6x1mKoVyf+FFn26iYqXJRgzIZZcZ5V6hrE0Qg39kZm4az48o0AUbf6Sp4SLdvnuMa2sVNwHBboS7EJkm57XQPVU3/QpyNLHbWDdzwtrlS+ez30S3AdYhLKEOxAG8weOnyrtLJAUen9mTkol8oII1edf7mWWbWVf0nBmly21+nZcmCTISQBtdcyPaEno7fFQMDD26/s0lfKob4Kw8H
```

下面是一个使用上述 `ssh-keyscan` 输出结果的 `ConfigMap` 对象示例：

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  labels:
    app.kubernetes.io/name: argocd-ssh-known-hosts-cm
    app.kubernetes.io/part-of: argocd
  name: argocd-ssh-known-hosts-cm
data:
  ssh_known_hosts: |
    # This file was automatically generated by hack/update-ssh-known-hosts.sh. DO NOT EDIT
    [ssh.github.com]:443 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBEmKSENjQEezOmxkZMy7opKgwFB9nkt5YRrYMjNuG5N87uRgg6CLrbo5wAdT/y6v0mKV0U2w0WZ2YB/++Tpockg=
    [ssh.github.com]:443 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOMqqnkVzrm0SdG6UOoqKLsabgH5C9okWi0dh2l9GKJl
    [ssh.github.com]:443 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCj7ndNxQowgcQnjshcLrqPEiiphnt+VTTvDP6mHBL9j1aNUkY4Ue1gvwnGLVlOhGeYrnZaMgRK6+PKCUXaDbC7qtbW8gIkhL7aGCsOr/C56SJMy/BCZfxd1nWzAOxSDPgVsmerOBYfNqltV9/hWCqBywINIR+5dIg6JTJ72pcEpEjcYgXkE2YEFXV1JHnsKgbLWNlhScqb2UmyRkQyytRLtL+38TGxkxCflmO+5Z8CSSNY7GidjMIZ7Q4zMjA2n1nGrlTDkzwDCsw+wqFPGQA179cnfGWOWRVruj16z6XyvxvjJwbz0wQZ75XK5tKSb7FNyeIEs4TT4jk+S4dhPeAUC5y+bDYirYgM4GC7uEnztnZyaVWQ7B381AK4Qdrwt51ZqExKbQpTUNn+EjqoTwvqNj4kqx5QUCI0ThS/YkOxJCXmPUWZbhjpCg56i+2aB6CmK2JGhn57K5mj0MNdBXA4/WnwH6XoPWJzK5Nyu2zB3nAZp+S5hpQs+p1vN1/wsjk=
    bitbucket.org ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBPIQmuzMBuKdWeF4+a2sjSSpBK0iqitSQ+5BM9KhpexuGt20JpTVM7u5BDZngncgrqDMbWdxMWWOGtZ9UgbqgZE=
    bitbucket.org ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIIazEu89wgQZ4bqs3d63QSMzYVa0MuJ2e2gKTKqu+UUO
    bitbucket.org ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDQeJzhupRu0u0cdegZIa8e86EG2qOCsIsD1Xw0xSeiPDlCr7kq97NLmMbpKTX6Esc30NuoqEEHCuc7yWtwp8dI76EEEB1VqY9QJq6vk+aySyboD5QF61I/1WeTwu+deCbgKMGbUijeXhtfbxSxm6JwGrXrhBdofTsbKRUsrN1WoNgUa8uqN1Vx6WAJw1JHPhglEGGHea6QICwJOAr/6mrui/oB7pkaWKHj3z7d1IC4KWLtY47elvjbaTlkN04Kc/5LFEirorGYVbt15kAUlqGM65pk6ZBxtaO3+30LVlORZkxOh+LKL/BvbZ/iRNhItLqNyieoQj/uh/7Iv4uyH/cV/0b4WDSd3DptigWq84lJubb9t/DnZlrJazxyDCulTmKdOR7vs9gMTo+uoIrPSb8ScTtvw65+odKAlBj59dhnVp9zd7QUojOpXlL62Aw56U4oO+FALuevvMjiWeavKhJqlR7i5n9srYcrNV7ttmDw7kf/97P5zauIhxcjX+xHv4M=
    github.com ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBEmKSENjQEezOmxkZMy7opKgwFB9nkt5YRrYMjNuG5N87uRgg6CLrbo5wAdT/y6v0mKV0U2w0WZ2YB/++Tpockg=
    github.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOMqqnkVzrm0SdG6UOoqKLsabgH5C9okWi0dh2l9GKJl
    github.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCj7ndNxQowgcQnjshcLrqPEiiphnt+VTTvDP6mHBL9j1aNUkY4Ue1gvwnGLVlOhGeYrnZaMgRK6+PKCUXaDbC7qtbW8gIkhL7aGCsOr/C56SJMy/BCZfxd1nWzAOxSDPgVsmerOBYfNqltV9/hWCqBywINIR+5dIg6JTJ72pcEpEjcYgXkE2YEFXV1JHnsKgbLWNlhScqb2UmyRkQyytRLtL+38TGxkxCflmO+5Z8CSSNY7GidjMIZ7Q4zMjA2n1nGrlTDkzwDCsw+wqFPGQA179cnfGWOWRVruj16z6XyvxvjJwbz0wQZ75XK5tKSb7FNyeIEs4TT4jk+S4dhPeAUC5y+bDYirYgM4GC7uEnztnZyaVWQ7B381AK4Qdrwt51ZqExKbQpTUNn+EjqoTwvqNj4kqx5QUCI0ThS/YkOxJCXmPUWZbhjpCg56i+2aB6CmK2JGhn57K5mj0MNdBXA4/WnwH6XoPWJzK5Nyu2zB3nAZp+S5hpQs+p1vN1/wsjk=
    gitlab.com ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBFSMqzJeV9rUzU4kWitGjeR4PWSa29SPqJ1fVkhtj3Hw9xjLVXVYrU9QlYWrOLXBpQ6KWjbjTDTdDkoohFzgbEY=
    gitlab.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIAfuCHKVTjquxvt6CM6tdG4SLp1Btn/nOeHHE5UOzRdf
    gitlab.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCsj2bNKTBSpIYDEGk9KxsGh3mySTRgMtXL583qmBpzeQ+jqCMRgBqB98u3z++J1sKlXHWfM9dyhSevkMwSbhoR8XIq/U0tCNyokEi/ueaBMCvbcTHhO7FcwzY92WK4Yt0aGROY5qX2UKSeOvuP4D6TPqKF1onrSzH9bx9XUf2lEdWT/ia1NEKjunUqu1xOB/StKDHMoX4/OKyIzuS0q/T1zOATthvasJFoPrAjkohTyaDUz2LN5JoH839hViyEG82yB+MjcFV5MU3N1l1QL3cVUCh93xSaua1N85qivl+siMkPGbO5xR/En4iEY6K2XPASUEMaieWVNTRCtJ4S8H+9
    ssh.dev.azure.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC7Hr1oTWqNqOlzGJOfGJ4NakVyIzf1rXYd4d7wo6jBlkLvCA4odBlL0mDUyZ0/QUfTTqeu+tm22gOsv+VrVTMk6vwRU75gY/y9ut5Mb3bR5BV58dKXyq9A9UeB5Cakehn5Zgm6x1mKoVyf+FFn26iYqXJRgzIZZcZ5V6hrE0Qg39kZm4az48o0AUbf6Sp4SLdvnuMa2sVNwHBboS7EJkm57XQPVU3/QpyNLHbWDdzwtrlS+ez30S3AdYhLKEOxAG8weOnyrtLJAUen9mTkol8oII1edf7mWWbWVf0nBmly21+nZcmCTISQBtdcyPaEno7fFQMDD26/s0lfKob4Kw8H
    vs-ssh.visualstudio.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC7Hr1oTWqNqOlzGJOfGJ4NakVyIzf1rXYd4d7wo6jBlkLvCA4odBlL0mDUyZ0/QUfTTqeu+tm22gOsv+VrVTMk6vwRU75gY/y9ut5Mb3bR5BV58dKXyq9A9UeB5Cakehn5Zgm6x1mKoVyf+FFn26iYqXJRgzIZZcZ5V6hrE0Qg39kZm4az48o0AUbf6Sp4SLdvnuMa2sVNwHBboS7EJkm57XQPVU3/QpyNLHbWDdzwtrlS+ez30S3AdYhLKEOxAG8weOnyrtLJAUen9mTkol8oII1edf7mWWbWVf0nBmly21+nZcmCTISQBtdcyPaEno7fFQMDD26/s0lfKob4Kw8H
```

注意，"argocd-sssh-known-hosts-cm "ConfigMap 将作为卷挂载在 "argocd-server "和 "argocd-repo-server "的 pod 中，挂载路径为"/app/config/ssh"。 它将在该目录下创建一个文件 "ssh_known_hosts"，其中包含 Argo CD 通过 SSH 连接 Git 仓库时使用的 SSH 已知主机数据。 ConfigMap 中的更改可能需要一段时间才能反映到 pod 中，这取决于你的 Kubernetes 配置。

### 使用代理配置存储库

版本库的代理可以与其他版本库配置一起在版本库秘钥的 "代理 "字段中指定。 Argo CD 使用此代理访问版本库。 如果没有自定义代理，Argo CD 会在版本库服务器中查找标准代理环境变量。

带代理的存储库示例：

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: private-repo
  namespace: argocd
  labels:
    argocd.argoproj.io/secret-type: repository
stringData:
  type: git
  url: https://github.com/argoproj/private-repo
  proxy: https://proxy-server-url:8888
  password: my-password
  username: my-username
```

### 遗留行为

在 Argo CD 2.0 及更早的版本中，存储库被存储为 `argocd-cm` 配置 maps 的一部分。 为了向后兼容，Argo CD 仍会尊重配置 maps 中的存储库，但这种存储库配置方式已被弃用，对它的支持将在未来的版本中移除。

```yaml
apiVersion: v1
kind: ConfigMap
data:
  repositories: |
    - url: https://github.com/argoproj/my-private-repository
      passwordSecret:
        name: my-secret
        key: password
      usernameSecret:
        name: my-secret
        key: username
  repository.credentials: |
    - url: https://github.com/argoproj
      passwordSecret:
        name: my-secret
        key: password
      usernameSecret:
        name: my-secret
        key: username
---
apiVersion: v1
kind: Secret
metadata:
  name: my-secret
  namespace: argocd
stringData:
  password: my-password
  username: my-username
```

## 集群

集群凭据与存储库或存储库凭据一样存储在秘密中。 每个秘密必须有标签 `argocd.argoproj.io/secret-type: cluster`。

秘密数据必须包括以下字段：

* `name` - 集群名称
* `server` - 集群 api 服务器 url
* `namespaces` - 以逗号分隔的可选名称空间列表，这些名称空间可在该集群中访问。如果 namespace 列表不为空，则集群级资源将被忽略。
* `clusterResources` - 可选布尔字符串（`"true"`或`"false"`），用于确定 Argo CD 是否可以管理该集群上的集群级资源。此设置仅在管理的 namespace 列表不为空时被引用。
* `project` - 可选字符串，用于指定此集群为项目范围集群。
* `config` - 以下数据结构的 JSON 表示：

```yaml
# Basic authentication settings
username: string
password: string
# Bearer authentication settings
bearerToken: string
# IAM authentication configuration
awsAuthConfig:
    clusterName: string
    roleARN: string
    profile: string
# Configure external command to supply client credentials
# See https://godoc.org/k8s.io/client-go/tools/clientcmd/api#ExecConfig
execProviderConfig:
    command: string
    args: [
      string
    ]
    env: {
      key: value
    }
    apiVersion: string
    installHint: string
# Transport layer security configuration settings
tlsClientConfig:
    # Base64 encoded PEM-encoded bytes (typically read from a client certificate file).
    caData: string
    # Base64 encoded PEM-encoded bytes (typically read from a client certificate file).
    certData: string
    # Server should be accessed without verifying the TLS certificate
    insecure: boolean
    # Base64 encoded PEM-encoded bytes (typically read from a client certificate key file).
    keyData: string
    # ServerName is passed to the server for SNI and is used in the client to check server
    # certificates against. If ServerName is empty, the hostname used to contact the
    # server is used.
    serverName: string
```

请注意，如果您指定要在 `execProviderConfig` 下运行的命令，该命令必须在 Argo CD 镜像中可用。 请参阅 [BYOI（自建镜像）](custom_tools.md#byoi-build-yourself-image)。

集群秘密示例：

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mycluster-secret
  labels:
    argocd.argoproj.io/secret-type: cluster
type: Opaque
stringData:
  name: mycluster.example.com
  server: https://mycluster.example.com
  config: |
    {
      "bearerToken": "<authentication token>",
      "tlsClientConfig": {
        "insecure": false,
        "caData": "<base64 encoded certificate>"
      }
    }
```

### EKS

被引用 argocd-k8s-auth 和 [IRSA](https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html) 的 EKS 集群秘密示例：

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mycluster-secret
  labels:
    argocd.argoproj.io/secret-type: cluster
type: Opaque
stringData:
  name: "mycluster.example.com"
  server: "https://mycluster.example.com"
  config: |
    {
      "awsAuthConfig": {
        "clusterName": "my-eks-cluster-name",
        "roleARN": "arn:aws:iam::<AWS_ACCOUNT_ID>:role/<IAM_ROLE_NAME>"
      },
      "tlsClientConfig": {
        "insecure": false,
        "caData": "<base64 encoded certificate>"
      }        
    }
```

请注意，您应该在 EKS 集群上启用 IRSA，创建一个适当的 IAM 角色，允许它承担其他 IAM 角色（Argo CD 需要承担的 "roleARN"），并制定一个承担角色策略，允许 argocd-application-controller 和 argocd-server pod 通过 OIDC 承担上述角色。

针对 `&lt;arn:aws:iam::<AWS_ACCOUNT_ID>:role/<ARGO_CD_MANAGEMENT_IAM_ROLE_NAME>` 的信任关系配置示例，Argo CD 需要使用该配置才能通过 IAM 执行操作。 确保集群已为其配置 [IAM OIDC Provider](https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html)。

```json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "Federated": "arn:aws:iam::<AWS_ACCOUNT_ID>:oidc-provider/oidc.eks.<AWS_REGION>.amazonaws.com/id/EXAMPLED539D4633E53DE1B71EXAMPLE"
            },
            "Action": "sts:AssumeRoleWithWebIdentity",
            "Condition": {
                "StringEquals": {
                    "oidc.eks.<AWS_REGION>.amazonaws.com/id/EXAMPLED539D4633E53DE1B71EXAMPLE:sub": ["system:serviceaccount:argocd:argocd-application-controller", "system:serviceaccount:argocd:argocd-server"],
                    "oidc.eks.<AWS_REGION>.amazonaws.com/id/EXAMPLED539D4633E53DE1B71EXAMPLE:aud": "sts.amazonaws.com"
                }
            }
        }
    ]
}
```

Argo CD 管理角色也需要被允许承担其他角色，在这种情况下，我们希望它承担 `arn:aws:iam::<AWS_ACCOUNT_ID>:role/<IAM_ROLE_NAME>`，这样它就可以管理映射到该角色的集群。 这可以扩展为允许承担多个角色，可以是角色 ARN 的显式数组，也可以在适当的地方使用 `*`。

```json
{
    "Version" : "2012-10-17",
    "Statement" : {
      "Effect" : "Allow",
      "Action" : "sts:AssumeRole",
      "Principal" : {
        "AWS" : "<arn:aws:iam::<AWS_ACCOUNT_ID>:role/<IAM_ROLE_NAME>"
      }
    }
  }
```

argocd-application-controller "和 "argocd-server "的服务帐户配置示例。

警告 一旦在服务账户上设置了 Annotations，就需要重新启动应用程序控制器和服务器 pod。

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  annotations:
    eks.amazonaws.com/role-arn: "<arn:aws:iam::<AWS_ACCOUNT_ID>:role/<ARGO_CD_MANAGEMENT_IAM_ROLE_NAME>"
  name: argocd-application-controller
---
apiVersion: v1
kind: ServiceAccount
metadata:
  annotations:
    eks.amazonaws.com/role-arn: "<arn:aws:iam::<AWS_ACCOUNT_ID>:role/<ARGO_CD_MANAGEMENT_IAM_ROLE_NAME>"
  name: argocd-server
```

反过来，每个受管集群的 `roleARN` 需要添加到各自集群的 `aws-auth` config maps 中（请参阅[启用 IAM principal 访问您的集群](https://docs.aws.amazon.com/eks/latest/userguide/add-user-role.html)），同时还要有一个假设角色策略，允许 Argo CD pod 角色假设该角色。

示例 假定由 Argo CD 管理的集群的角色策略：

```json
{
    "Version" : "2012-10-17",
    "Statement" : {
      "Effect" : "Allow",
      "Action" : "sts:AssumeRole",
      "Principal" : {
        "AWS" : "<arn:aws:iam::<AWS_ACCOUNT_ID>:role/<ARGO_CD_MANAGEMENT_IAM_ROLE_NAME>"
      }
    }
  }
```

由 Argo CD 管理的集群的 kube-system/aws-auth configmaps 示例：

```yaml
apiVersion: v1
data:
  # Other groups and accounts omitted for brevity. Ensure that no other rolearns and/or groups are inadvertently removed, 
  # or you risk borking access to your cluster.
  #
  # The group name is a RoleBinding which you use to map to a [Cluster]Role. See https://kubernetes.io/docs/reference/access-authn-authz/rbac/#role-binding-examples  
  mapRoles: |
    - "groups":
      - "<GROUP-NAME-IN-K8S-RBAC>"
      "rolearn": "<arn:aws:iam::<AWS_ACCOUNT_ID>:role/<IAM_ROLE_NAME>"
      "username": "<some-username>"
```

### GKE

被引用 argocd-k8s-auth 和 [Workload Identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity) 的 GKE 集群秘密示例：

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mycluster-secret
  labels:
    argocd.argoproj.io/secret-type: cluster
type: Opaque
stringData:
  name: mycluster.example.com
  server: https://mycluster.example.com
  config: |
    {
      "execProviderConfig": {
        "command": "argocd-k8s-auth",
        "args": ["gcp"],
        "apiVersion": "client.authentication.k8s.io/v1beta1"
      },
      "tlsClientConfig": {
        "insecure": false,
        "caData": "<base64 encoded certificate>"
      }
    }
```

请注意，您必须在 GKE 集群上启用 Workload Identity，创建具有适当 IAM 角色的 GCP 服务账户，并将其绑定到用于 argocd-application-controller 和 argocd-server 的 Kubernetes 服务账户（在用户界面上显示 Pod 日志）。请参阅 [Use Workload Identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity) 和 [Authenticating to Kubernetes API server](https://cloud.google.com/kubernetes-engine/docs/how-to/api-server-authentication)。

### AKS

使用 argocd-k8s-auth 和 [kubelogin](https://github.com/Azure/kubelogin) 的 Azure 集群秘密示例。 argocd-k8s-auth execProviderConfig 的选项 _azure_ 封装了 kubelogin 的 _get-token_ 命令。 根据所需的身份验证流程（devicecode、spn、roc、msi、azurecli、workloadidentity），将环境变量 AAD_LOGIN_METHOD 设置为该值。 根据所需的身份验证流程，设置其他适当的环境变量。

|Variable Name|Description|
|-------------|-----------|
|AAD_LOGIN_METHOD|One of devicecode, spn, ropc, msi, azurecli, or workloadidentity|
|AAD_SERVICE_PRINCIPAL_CLIENT_CERTIFICATE|AAD client cert in pfx. Used in spn login|
|AAD_SERVICE_PRINCIPAL_CLIENT_ID|AAD client application ID|
|AAD_SERVICE_PRINCIPAL_CLIENT_SECRET|AAD client application secret|
|AAD_USER_PRINCIPAL_NAME|Used in the ropc flow|
|AAD_USER_PRINCIPAL_PASSWORD|Used in the ropc flow|
|AZURE_TENANT_ID|The AAD tenant ID.|
|AZURE_AUTHORITY_HOST|Used in the WorkloadIdentityLogin flow|
|AZURE_FEDERATED_TOKEN_FILE|Used in the WorkloadIdentityLogin flow|
|AZURE_CLIENT_ID|Used in the WorkloadIdentityLogin flow|

除上述环境变量外，argocd-k8s-auth 还接受两个额外的环境变量，用于设置 AAD 环境和 AAD 服务器应用程序 ID。 如果未指定，AAD 服务器应用程序 ID 默认为 6dae42f8-4368-4678-94ff-3960e28e3630。详情请参见 [here](https://github.com/azure/kubelogin#exec-plugin-format)。

|变量名|变量描述| |-------------|-----------| |AAD_ENVIRONMENT_NAME|要使用的azure 环境，默认为 AzurePublicCloud||AAD_SERVER_APPLICATION_ID| 可选的 AAD 服务器应用程序 ID，默认为 6dae42f8-4368-4678-94ff-3960e28e3630| |AAD_SERVER_APPLICATION_ID| 可选的 AAD 服务器应用程序 ID，默认为 AzurePublicCloud。

这是一个使用 [联合工作负载登录流程](https://github.com/Azure/kubelogin#azure-workload-federated-identity-non-interactive) 的示例。联合令牌文件需要作为 secret 挂载到 argoCD 中，以便在流程中使用。令牌文件的位置需要在环境变量 AZURE_FEDERATED_TOKEN_FILE 中设置。

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mycluster-secret
  labels:
    argocd.argoproj.io/secret-type: cluster
type: Opaque
stringData:
  name: mycluster.example.com
  server: https://mycluster.example.com
  config: |
    {
      "execProviderConfig": {
        "command": "argocd-k8s-auth",
        "env": {
          "AAD_ENVIRONMENT_NAME": "AzurePublicCloud",
          "AZURE_CLIENT_ID": "fill in client id",
          "AZURE_TENANT_ID": "fill in tenant id",
          "AZURE_FEDERATED_TOKEN_FILE": "/opt/path/to/federated_file.json",
          "AZURE_AUTHORITY_HOST": "https://login.microsoftonline.com/",
          "AAD_LOGIN_METHOD": "workloadidentity"
        },
        "args": ["azure"],
        "apiVersion": "client.authentication.k8s.io/v1beta1"
      },
      "tlsClientConfig": {
        "insecure": false,
        "caData": "<base64 encoded certificate>"
      }
    }
```

这是一个使用 spn（服务 principal 名称）流程的示例。

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mycluster-secret
  labels:
    argocd.argoproj.io/secret-type: cluster
type: Opaque
stringData:
  name: mycluster.example.com
  server: https://mycluster.example.com
  config: |
    {
      "execProviderConfig": {
        "command": "argocd-k8s-auth",
        "env": {
          "AAD_ENVIRONMENT_NAME": "AzurePublicCloud",
          "AAD_SERVICE_PRINCIPAL_CLIENT_SECRET": "fill in your service principal client secret",
          "AZURE_TENANT_ID": "fill in tenant id",
          "AAD_SERVICE_PRINCIPAL_CLIENT_ID": "fill in your service principal client id",
          "AAD_LOGIN_METHOD": "spn"
        },
        "args": ["azure"],
        "apiVersion": "client.authentication.k8s.io/v1beta1"
      },
      "tlsClientConfig": {
        "insecure": false,
        "caData": "<base64 encoded certificate>"
      }
    }
```

## Helm 图表存储库

非标准 Helm Chart 版本库必须明确注册。 每个版本库必须有 `url`、`type` 和 `name` 字段。 对于私人 Helm 版本库，您可能需要使用 `用户名`、`密码`、`tlsClientCertData` 和 `tlsClientCertKey` 字段配置访问凭证和 HTTPS 设置。

例如

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: istio
  namespace: argocd
  labels:
    argocd.argoproj.io/secret-type: repository
stringData:
  name: istio.io
  url: https://storage.googleapis.com/istio-prerelease/daily-build/master-latest-daily/charts
  type: helm
---
apiVersion: v1
kind: Secret
metadata:
  name: argo-helm
  namespace: argocd
  labels:
    argocd.argoproj.io/secret-type: repository
stringData:
  name: argo
  url: https://argoproj.github.io/argo-helm
  type: helm
  username: my-username
  password: my-password
  tlsClientCertData: ...
  tlsClientCertKey: ...
```

## 排除/纳入资源

可以将资源排除在发现和同步之外，这样 Argo CD 就不会发现这些资源。 例如，apiGroup/kind `events.k8s.io/*`、`metrics.k8s.io/*`、`coordination.k8s.io/Lease` 和 `""/Endpoints` 始终被排除在外。 用例：

* 您有时间问题，希望排除有问题的资源。
* 有很多资源会影响 Argo CD 的性能。
* 限制 Argo CD 访问某些类型的资源，例如秘密。请参阅 [security.md#cluster-rbac](security.md#cluster-rbac)。

要对此进行配置，请编辑 `argocd-cm` config maps：

```shell
kubectl edit configmap argocd-cm -n argocd
```

添加 "resource.exclusions"，例如：

```yaml
apiVersion: v1
data:
  resource.exclusions: |
    - apiGroups:
      - "*"
      kinds:
      - "*"
      clusters:
      - https://192.168.0.20
kind: ConfigMap
```

资源.排除 "节点是一个对象列表。 每个对象可以有：

* `apiGroups` 与 API group 匹配的 globs 列表。
* `kinds` 要匹配的种类列表。可以是 `"*"` 来匹配所有。
* `clusters` 与集群匹配的 globs 列表。

如果三者都匹配，则忽略该资源。

除排除项外，您还可以使用 `resource.inclusions` 设置配置包含的资源列表。 默认情况下，所有资源组/种类都包含在内。 `resource.inclusions` 设置允许自定义包含的组/种类列表：

```yaml
apiVersion: v1
data:
  resource.inclusions: |
    - apiGroups:
      - "*"
      kinds:
      - Deployment
      clusters:
      - https://192.168.0.20
kind: ConfigMap
```

resource.inclusions "和 "resource.exclusions "可同时使用。 最终资源列表包括 "resource.inclusions "中指定的组/种类，减去 "resource.exclusions "设置中指定的组/种类。

备注

* 在 YAML 中引用 globs 以避免解析错误。
* 无效的 globs 会导致整条规则被忽略。
* 如果添加的规则与现有资源相匹配，这些资源将在界面中显示为 `OutOfSync`。

## 自动尊重控制器的 RBAC

Argocd controller can be restricted from discovering/syncing specific resources using just controller rbac, without having to manually configure resource exclusions.
This feature can be enabled by setting `resource.respectRBAC` key in argocd cm, once it is set the controller will automatically stop watching for resources 
that it does not have the permission to list/access. Possible values for `resource.respectRBAC` are:
    - `strict` : This setting checks whether the list call made by controller is forbidden/unauthorized and if it is, it will cross-check the permission by making a `SelfSubjectAccessReview` call for the resource.
    - `normal` : This will only check whether the list call response is forbidden/unauthorized and skip `SelfSubjectAccessReview` call, to minimize any extra api-server calls.
    - unset/empty (default) : This will disable the feature and controller will continue to monitor all resources.

可以接受 kube api-server 调用增加的用户可以选择 "严格 "选项，而担心 api 调用增加并愿意在准确性上妥协的用户可以选择 "正常 "选项。

备注

* 当设置为使用 "严格 "模式时，控制器必须拥有 rbac 权限才能 "创建""自主体访问审查 "资源
* 自主体访问审查 "请求将只针对 "列表 "动词，假定如果允许对资源使用 "列表"，则控制器也可使用所有其他权限。

将 `resource.respectRBAC` 设置为 `strict` 的 argocd cm 示例：

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: argocd-cm
data:
  resource.respectRBAC: "strict"
```

## 资源自定义标签

使用 `resource.customLabels`（逗号分隔字符串）配置的自定义标签将显示在用户界面中（对于任何定义了自定义标签的资源）。

## SSO 和 RBAC

* SSO 配置详情：[SSO](./user-management/index.md)
* RBAC 配置详情：[RBAC](./rbac.md)

## 管理 Argo CD 使用 Argo CD

Argo CD 能够自我管理，因为所有设置都由 Kubernetes 配置清单表示。建议的方法是创建基于 [Kustomize](https://github.com/kubernetes-sigs/kustomize)的应用程序，该应用程序使用 [https://github.com/argoproj/argo-cd](https://github.com/argoproj/argo-cd/tree/stable/manifests) 中的 Argo CD 基础配置清单，并在上面应用所需的更改。

kustomize.yaml` 示例：

```yaml
# additional resources like ingress rules, cluster and repository secrets.
resources:
- github.com/argoproj/argo-cd//manifests/cluster-install?ref=v1.0.1
- clusters-secrets.yaml
- repos-secrets.yaml

# changes to config maps
patches:
- path: overlays/argo-cd-cm.yaml
```

自管理 Argo CD 配置的实时示例可在 [https://cd.apps.argoproj.io](https://cd.apps.argoproj.io) 获取，配置存储在 [argoproj/argoproj-deployments](https://github.com/argoproj/argoproj-deployments/tree/master/argocd) 中。

注意 您需要使用 GitHub 帐户登录才能访问 [https://cd.apps.argoproj.io](https://cd.apps.argoproj.io)。